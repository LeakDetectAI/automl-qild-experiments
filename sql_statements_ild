create sequence leakage_detection.avail_jobs_job_id_seq;

alter sequence leakage_detection.avail_jobs_job_id_seq owner to autoscaadmin;

CREATE TABLE leakage_detection.avail_jobs (
    job_id             integer          DEFAULT nextval('leakage_detection.avail_jobs_job_id_seq'::regclass) NOT NULL,
    fold_id            integer       NOT NULL,
    dataset_name       text          NOT NULL,
    dataset_params     json,
    base_learner       text             NOT NULL,
    detector_method    text             NOT NULL,
    fit_params         json,
    learner_params     json,
    hp_ranges          json,
    hp_iters           integer          DEFAULT 50,
    inner_folds        integer          DEFAULT 3,
    validation_loss    text,
    cv_iterations      integer          DEFAULT 10,
    n_hypothesis       integer          DEFAULT 10,
    learning_problem   text             NOT NULL,
    experiment_schema  text             NOT NULL,
    experiment_table   text,
    seed               integer          DEFAULT 123,
    is_gpu             boolean default false                                                     not null,
    hash_value         text             DEFAULT ''::text,
    duration           text,
    job_allocated_time timestamp,
    job_end_time       timestamp,
    evaluation_time    double precision DEFAULT 0,
    CONSTRAINT avail_jobs_pk PRIMARY KEY (job_id)
);


alter table leakage_detection.avail_jobs owner to autoscaadmin;

create sequence leakage_detection.running_jobs_running_id_seq;

alter sequence leakage_detection.running_jobs_running_id_seq owner to autoscaadmin;

CREATE TABLE leakage_detection.running_jobs (
    running_id    integer  DEFAULT nextval('leakage_detection.running_jobs_running_id_seq'::regclass) NOT NULL,
    job_id        integer  NOT NULL,
    cluster_id    integer  NOT NULL,
    finished      boolean  DEFAULT false NOT NULL,
    interrupted   boolean  DEFAULT false NOT NULL,
    error_history text     DEFAULT 'NA'::text,
    PRIMARY KEY (job_id)
);


alter table leakage_detection.running_jobs owner to autoscaadmin;

create unique index running_jobs_running_id_idx on leakage_detection.running_jobs (running_id);


create view results.leakage_detection_results
            (job_id, fold_id, imbalance, delay, dataset_id, base_detector, detection_method, f1score,
             accuracy, mathewscorrelationcoefficient, balancedaccuracy, falsepositiverate, falsenegativerate,
             hypothesis, evaluation_time)
as
SELECT
       jobs.job_id,
       results.fold_id,
       results.imbalance,
       results.delay,
       (jobs.dataset_params ->> 'dataset_id'::text)::integer          AS dataset_id,
       results.base_detector,
       results.detection_method,
       results.f1score,
       results.accuracy,
       results.mathewscorrelationcoefficient,
       results.balancedaccuracy,
       results.falsepositiverate,
       results.falsenegativerate,
       results.hypothesis,
       jobs.evaluation_time
FROM results.leakage_detection results JOIN leakage_detection.avail_jobs jobs USING (job_id);

alter table results.leakage_detection_results
    owner to autoscaadmin;

DELETE from leakage_detection.running_jobs where True;
alter sequence leakage_detection.running_jobs_running_id_seq restart with 1;

ALTER sequence leakage_detection_new.avail_jobs_job_id_seq restart with 14878
SELECT nextval('leakage_detection_new.avail_jobs_job_id_seq')-1;
SELECT nextval('leakage_detection_new.running_jobs_running_id_seq')-1;


DELETE from leakage_detection_new.avail_jobs where job_id>=2605;
ALTER sequence leakage_detection_new.avail_jobs_job_id_seq restart with 2605;
UPDATE leakage_detection_new.avail_jobs
SET job_end_time = leakage_detection.avail_jobs.job_end_time, job_allocated_time = leakage_detection.avail_jobs.job_allocated_time
FROM leakage_detection.avail_jobs
WHERE leakage_detection.avail_jobs.job_id = leakage_detection_new.avail_jobs.job_id;
SELECT * FROM leakage_detection_new.avail_jobs row WHERE job_id<=1827 and EXISTS(SELECT job_id FROM leakage_detection_new.running_jobs r WHERE r.job_id = row.job_id and r.finished=False) order by job_id;
SELECT * FROM leakage_detection_new.avail_jobs row WHERE job_id<=1827 and not EXISTS(SELECT job_id FROM leakage_detection_new.running_jobs r WHERE r.job_id = row.job_id) order by job_id;

SELECT row.job_id, row.finished, row.cluster_id FROM leakage_detection_new.running_jobs row WHERE row.finished=False and EXISTS(SELECT job_id FROM leakage_detection_new.avail_jobs r WHERE r.job_id = row.job_id and r.is_gpu=False) order by cluster_id
UPDATE leakage_detection_new.avail_jobs
SET job_end_time = leakage_detection.avail_jobs.job_end_time,
    job_allocated_time = leakage_detection.avail_jobs.job_allocated_time,
    evaluation_time = leakage_detection.avail_jobs.evaluation_time
FROM leakage_detection.avail_jobs
WHERE leakage_detection.avail_jobs.job_id = leakage_detection_new.avail_jobs.job_id;
UPDATE leakage_detection_new.avail_jobs set is_gpu=true where base_learner='mine_mi_estimator';


DELETE from leakage_detection_new.running_jobs where True;
alter sequence leakage_detection.running_jobs_running_id_seq restart with 1;
UPDATE leakage_detection_new.running_jobs set running_id=job_id where true;
alter sequence leakage_detection.running_jobs_running_id_seq restart with 1831;

DELETE from leakage_detection_new.avail_jobs where job_id>=1831;
alter sequence leakage_detection_new.avail_jobs_job_id_seq restart with 1831;
