create sequence mutual_information.avail_jobs_job_id_seq;
alter sequence mutual_information.avail_jobs_job_id_seq owner to autoscaadmin;

create table mutual_information.avail_jobs
(
    job_id             integer default nextval('mutual_information.avail_jobs_job_id_seq'::regclass) not null
        constraint avail_jobs_pk
            primary key,
    fold_id            integer                                                                   not null,
    dataset            text                                                                      not null,
    learner            text                                                                      not null,
    experiment_schema  text                                                                      not null,
    experiment_table   text,
    dataset_params     json,
    fit_params         json,
    learner_params     json,
    hp_ranges          json,
    hp_iters           integer default 50,
    is_gpu             boolean default false                                                     not null,
    seed               integer default 123,
    inner_folds        integer default 3                                                         not null,
    duration           text,
    learning_problem   text,
    validation_loss    text,
    hash_value         text    default ''::text,
    job_allocated_time timestamp,
    job_end_time       timestamp,
    evaluation_time double precision
);

alter table mutual_information.avail_jobs owner to autoscaadmin;

create sequence mutual_information.running_jobs_running_id_seq;

alter sequence mutual_information.running_jobs_running_id_seq owner to autoscaadmin;

ALTER SEQUENCE mutual_information.avail_jobs_job_id_seq RESTART WITH 5;


create table mutual_information.running_jobs
(
    running_id    integer default nextval('mutual_information.running_jobs_running_id_seq'::regclass) not null,
    job_id        integer                                                                         not null
        primary key,
    cluster_id    integer                                                                         not null,
    finished      boolean default false                                                           not null,
    interrupted   boolean default false                                                           not null,
    error_history text    default 'NA'::text
);

alter table mutual_information.running_jobs  owner to autoscaadmin;

create unique index running_jobs_running_id_idx on mutual_information.running_jobs (running_id);

create table results.classification
(
    job_id                        integer not null primary key,
    cluster_id                    integer not null,
    f1score                       double precision,
    accuracy                      double precision,
    aucscore                      double precision,
    mathewscorrelationcoefficient double precision,
    informedness                  double precision,
    tp                            double precision,
    tn                            double precision,
    fp                            double precision,
    fn                            double precision,
    santhivardyupperbound         double precision,
    hellmanravivupperbound        double precision,
    fanoslowerbound               double precision,
    fanosAdjustedlowerbound        double precision,
    estimatedmutualinformationscore double precision
);

alter table results.classification
    owner to autoscaadmin;
alter table results.classification drop column tp, drop column tn, drop column fp, drop column fn;
alter table results.mutual_information drop column tp, drop column tn, drop column fp, drop column fn;

create table results.mutual_information
(
    job_id                        integer not null primary key,
    cluster_id                    integer not null,
    estimatedmutualinformation    double precision,
    estimatedmutualinformationscore double precision,
    f1score                       double precision,
    accuracy                      double precision,
    aucscore                      double precision,
    mathewscorrelationcoefficient double precision,
    informedness                  double precision,
    santhivardyupperbound         double precision,
    hellmanravivupperbound        double precision,
    fanoslowerbound               double precision,
    fanosAdjustedlowerbound        double precision
);

alter table mutual_information.avail_jobs add column evaluation_time double precision;
alter table classification.avail_jobs add column evaluation_time double precision;
ALTER SEQUENCE mutual_information.running_jobs_running_id_seq RESTART WITH 1;
ALTER SEQUENCE classification.running_jobs_running_id_seq RESTART WITH 1;
UPDATE classification.avail_jobs set evaluation_time=0, job_allocated_time=NULL, job_end_time=NULL where true;
UPDATE mutual_information.avail_jobs set evaluation_time=0, job_allocated_time=NULL, job_end_time=NULL where true;
DELETE from mutual_information.running_jobs where true;
DELETE from classification.running_jobs where true;
DELETE from results.classification where true;
DELETE from results.mutual_information where true;
SELECT COUNT(*) from mutual_information.running_jobs group by finished;
SELECT COUNT(*) FROM mutual_information.avail_jobs row WHERE (is_gpu = False) AND NOT EXISTS(SELECT job_id FROM mutual_information.running_jobs r WHERE r.interrupted = FALSE AND r.job_id = row.job_id);
SELECT COUNT(*) FROM mutual_information.avail_jobs
DELETE from automl.avail_jobs where job_id>=2;
ALTER SEQUENCE automl.avail_jobs_job_id_seq RESTART WITH 2;
ALTER SEQUENCE automl.running_jobs_running_id_seq RESTART WITH 1;
rm logs/* optimizers/* results/*

create sequence mutual_information_new.avail_jobs_job_id_seq;
alter sequence mutual_information_new.avail_jobs_job_id_seq owner to autoscaadmin;
create sequence mutual_information_new.running_jobs_running_id_seq;
alter sequence mutual_information_new.running_jobs_running_id_seq owner to autoscaadmin;

create table if not exists mutual_information_new.avail_jobs
(
    job_id             integer          default nextval('mutual_information_new.avail_jobs_job_id_seq'::regclass) not null
        constraint avail_jobs_pk
            primary key,
    fold_id            integer                                                                                not null,
    dataset            text                                                                                   not null,
    learner            text                                                                                   not null,
    experiment_schema  text                                                                                   not null,
    experiment_table   text,
    dataset_params     json,
    fit_params         json,
    learner_params     json,
    hp_ranges          json,
    hp_iters           integer          default 50,
    is_gpu             boolean          default false                                                         not null,
    seed               integer          default 123,
    inner_folds        integer          default 3                                                             not null,
    duration           text,
    learning_problem   text,
    validation_loss    text,
    hash_value         text             default ''::text,
    job_allocated_time timestamp,
    job_end_time       timestamp,
    evaluation_time    double precision default 0
);

alter table mutual_information_new.avail_jobs
    owner to autoscaadmin;

create table if not exists mutual_information_new.running_jobs
(
    running_id    integer default nextval('mutual_information_new.running_jobs_running_id_seq'::regclass) not null,
    job_id        integer                                                                             not null
        primary key,
    cluster_id    integer                                                                             not null,
    finished      boolean default false                                                               not null,
    interrupted   boolean default false                                                               not null,
    error_history text    default 'NA'::text
);

alter table mutual_information_new.running_jobs
    owner to autoscaadmin;

create unique index if not exists running_jobs_running_id_idx
    on mutual_information_new.running_jobs (running_id);

SELECT COUNT(*) from automl.running_jobs group by finished;
DELETE from automl.running_jobs where finished=False;
SELECT COUNT(*) FROM automl.avail_jobs row WHERE (is_gpu = False) AND NOT EXISTS(SELECT job_id FROM automl.running_jobs r WHERE r.interrupted = FALSE AND r.job_id = row.job_id);
SELECT COUNT(*) FROM results.automl;
SELECT * from automl.avail_jobs;

ALTER SEQUENCE automl.running_jobs_running_id_seq RESTART WITH 1;
create table results.automl
(
    job_id                          integer not null
        constraint automl_pkey
            primary key,
    cluster_id                      integer not null,
    f1score                         double precision,
    accuracy                        double precision,
    mathewscorrelationcoefficient   double precision,
    santhivardyupperbound           double precision,
    hellmanravivupperbound          double precision,
    fanoslowerbound                 double precision,
    fanosadjustedlowerbound         double precision,
    estimatedmutualinformationscore double precision,
    mcmcbayesmi                     double precision,
    mcmcloglossbayesmi              double precision,
    mcmcpcsoftmaxbayesmi            double precision,
    mcmcsoftmaxbayesmi              double precision,
    midpointmi                      double precision,
    loglossmi                       double precision,
    loglossmiisotonicregression     double precision,
    loglossmiplattscaling           double precision,
    loglossmibetacalibration        double precision,
    loglossmitemperaturescaling     double precision,
    loglossmihistogrambinning       double precision,
    pcsoftmaxmi                     double precision,
    pcsoftmaxmiisotonicregression   double precision,
    pcsoftmaxmiplattscaling         double precision,
    pcsoftmaxmibetacalibration      double precision,
    pcsoftmaxmitemperaturescaling   double precision,
    pcsoftmaxmihistogrambinning     double precision
);

alter table results.automl owner to autoscaadmin;

create view results.automl_agg
            (job_id, cluster_id, f1score, accuracy, mathewscorrelationcoefficient, santhivardyupperbound,
             hellmanravivupperbound, fanoslowerbound, fanosadjustedlowerbound, estimatedmutualinformationscore, fold_id,
             dataset, learner, experiment_schema, experiment_table, dataset_params, fit_params, learner_params,
             hp_ranges, hp_iters, is_gpu, seed, inner_folds, duration, learning_problem, validation_loss, hash_value,
             job_allocated_time, job_end_time, evaluation_time, n_classes, n_features, flip_y)
as
SELECT results.job_id,
       results.cluster_id,
       results.f1score,
       results.accuracy,
       results.mathewscorrelationcoefficient,
       results.santhivardyupperbound,
       results.hellmanravivupperbound,
       results.fanoslowerbound,
       results.fanosadjustedlowerbound,
       results.estimatedmutualinformationscore,
       jobs.fold_id,
       jobs.dataset,
       jobs.learner,
       jobs.experiment_schema,
       jobs.experiment_table,
       jobs.dataset_params,
       jobs.fit_params,
       jobs.learner_params,
       jobs.hp_ranges,
       jobs.hp_iters,
       jobs.is_gpu,
       jobs.seed,
       jobs.inner_folds,
       jobs.duration,
       jobs.learning_problem,
       jobs.validation_loss,
       jobs.hash_value,
       jobs.job_allocated_time,
       jobs.job_end_time,
       jobs.evaluation_time,
       (jobs.dataset_params ->> 'n_classes'::text)::integer       AS n_classes,
       (jobs.dataset_params ->> 'n_features'::text)::integer      AS n_features,
       (jobs.dataset_params ->> 'flip_y'::text)::double precision AS flip_y
FROM results.automl results
         JOIN automl.avail_jobs jobs USING (job_id);



create view results.automl_agg
            (job_id, cluster_id, f1score, accuracy, mathewscorrelationcoefficient, santhivardyupperbound,
             hellmanravivupperbound, fanoslowerbound, fanosadjustedlowerbound, estimatedmutualinformationscore,
             mcmcbayesmi, mcmcloglossbayesmi, mcmcpcsoftmaxbayesmi, mcmcsoftmaxbayesmi, midpointmi, loglossmi,
             loglossmiisotonicregression, loglossmiplattscaling, loglossmibetacalibration, loglossmitemperaturescaling,
             loglossmihistogrambinnin, pcsoftmaxmi, pcsoftmaxmiisotonicregression, pcsoftmaxmiplattscaling,
             pcsoftmaxmibetacalibration, pcsoftmaxmitemperaturescaling, pcsoftmaxmihistogrambinning, fold_id, dataset,
             learner, experiment_schema, experiment_table, dataset_params, fit_params, learner_params, hp_ranges,
             hp_iters, is_gpu, seed, inner_folds, duration, learning_problem, validation_loss, hash_value,
             job_allocated_time, job_end_time, evaluation_time, n_classes, n_features, flip_y)
as
SELECT results.job_id,
       results.cluster_id,
       results.f1score,
       results.accuracy,
       results.mathewscorrelationcoefficient,
       results.santhivardyupperbound,
       results.hellmanravivupperbound,
       results.fanoslowerbound,
       results.fanosadjustedlowerbound,
       results.estimatedmutualinformationscore,
       results.mcmcbayesmi,
       results.mcmcloglossbayesmi,
       results.mcmcpcsoftmaxbayesmi,
       results.mcmcsoftmaxbayesmi,
       results.midpointmi,
       results.loglossmi,
       results.loglossmiisotonicregression,
       results.loglossmiplattscaling,
       results.loglossmibetacalibration,
       results.loglossmitemperaturescaling,
       results.loglossmihistogrambinning,
       results.pcsoftmaxmi,
       results.pcsoftmaxmiisotonicregression,
       results.pcsoftmaxmiplattscaling,
       results.pcsoftmaxmibetacalibration,
       results.pcsoftmaxmitemperaturescaling,
       results.pcsoftmaxmihistogrambinning,
       jobs.fold_id,
       jobs.dataset,
       jobs.learner,
       jobs.experiment_schema,
       jobs.experiment_table,
       jobs.dataset_params,
       jobs.fit_params,
       jobs.learner_params,
       jobs.hp_ranges,
       jobs.hp_iters,
       jobs.is_gpu,
       jobs.seed,
       jobs.inner_folds,
       jobs.duration,
       jobs.learning_problem,
       jobs.validation_loss,
       jobs.hash_value,
       jobs.job_allocated_time,
       jobs.job_end_time,
       jobs.evaluation_time,
       (jobs.dataset_params ->> 'n_classes'::text)::integer       AS n_classes,
       (jobs.dataset_params ->> 'n_features'::text)::integer      AS n_features,
       (jobs.dataset_params ->> 'flip_y'::text)::double precision AS flip_y
FROM results.automl results
         JOIN automl.avail_jobs jobs USING (job_id);

alter table results.automl
    owner to autoscaadmin;


create view results.mutual_information_aggregated_new
            (job_id, cluster_id, estimatedmutualinformation, estimatedmutualinformationscore, f1score, accuracy,
             mathewscorrelationcoefficient, santhivardyupperbound, hellmanravivupperbound, fanoslowerbound,
             fanosadjustedlowerbound, fold_id, dataset, learner, experiment_schema, experiment_table, dataset_params,
             fit_params, learner_params, hp_ranges, hp_iters, is_gpu, seed, inner_folds, duration, learning_problem,
             validation_loss, hash_value, job_allocated_time, job_end_time, evaluation_time, n_classes, n_features,
             flip_y)
as
SELECT results.job_id,
       results.cluster_id,
       results.estimatedmutualinformation,
       results.estimatedmutualinformationscore,
       results.f1score,
       results.accuracy,
       results.mathewscorrelationcoefficient,
       results.santhivardyupperbound,
       results.hellmanravivupperbound,
       results.fanoslowerbound,
       results.fanosadjustedlowerbound,
       jobs.fold_id,
       jobs.dataset,
       jobs.learner,
       jobs.experiment_schema,
       jobs.experiment_table,
       jobs.dataset_params,
       jobs.fit_params,
       jobs.learner_params,
       jobs.hp_ranges,
       jobs.hp_iters,
       jobs.is_gpu,
       jobs.seed,
       jobs.inner_folds,
       jobs.duration,
       jobs.learning_problem,
       jobs.validation_loss,
       jobs.hash_value,
       jobs.job_allocated_time,
       jobs.job_end_time,
       jobs.evaluation_time,
       (jobs.dataset_params ->> 'n_classes'::text)::integer       AS n_classes,
       (jobs.dataset_params ->> 'n_features'::text)::integer      AS n_features,
       (jobs.dataset_params ->> 'flip_y'::text)::double precision AS flip_y
FROM results.mutual_information_new results
         JOIN mutual_information_new.avail_jobs jobs USING (job_id);

alter table results.mutual_information_aggregated_new
    owner to autoscaadmin;

create table results.mutual_information_new
(
    job_id                          integer not null
        primary key,
    cluster_id                      integer not null,
    EstimatedMutualInformation      double precision,
    MCMCBayesMI      double precision,
    MCMCLogLossBayesMI      double precision,
    MCMCPCSoftmaxBayesMI      double precision,
    MCMCSoftmaxBayesMI      double precision,
    EstimatedMutualInformationScore double precision,
    f1score                         double precision,
    accuracy                        double precision,
    mathewscorrelationcoefficient   double precision,
    santhivardyupperbound           double precision,
    hellmanravivupperbound          double precision,
    fanoslowerbound                 double precision,
    fanosadjustedlowerbound         double precision
);

alter table results.mutual_information_new
    owner to autoscaadmin;
SELECT COUNT(*) from automl.running_jobs group by finished;
SELECT COUNT(*) FROM automl.avail_jobs group by learner, dataset;
SELECT * from automl.avail_jobs where learner='auto_gluon';
DELETE from automl.running_jobs where finished=False;
SELECT count(*) FROM automl.avail_jobs row WHERE (is_gpu = False) AND EXISTS(SELECT job_id FROM automl.running_jobs r WHERE r.finished = True AND r.job_id = row.job_id) group by learner, dataset;
UPDATE automl.avail_jobs set evaluation_time =  EXTRACT(EPOCH FROM(job_end_time - job_allocated_time)) where learner='auto_gluon';
alter table results.automl_agg
    owner to autoscaadmin;
UPDATE mutual_information_new.avail_jobs SET fit_params = fit_params::jsonb || '{"epochs":1000}' WHERE learner = 'mine_mi_estimator';
DELETE from mutual_information_new.running_jobs where true;
ALTER SEQUENCE mutual_information_new.running_jobs_running_id_seq RESTART WITH 1;
ALTER SEQUENCE mutual_information_new.avail_jobs_job_id_seq RESTART WITH 5;
DELETE from mutual_information_new.avail_jobs where job_id>4;
DELETE from results.mutual_information_new where true;

DELETE from mutual_information_new.avail_jobs where job_id>6;
DELETE from mutual_information_new.running_jobs where true;
DELETE from results.mutual_information_new where true;

ALTER SEQUENCE mutual_information_new.running_jobs_running_id_seq RESTART WITH 1;
ALTER SEQUENCE mutual_information_new.avail_jobs_job_id_seq RESTART WITH 7;

DELETE from mutual_information_new.avail_jobs where job_id>4;
DELETE from mutual_information_new.running_jobs where true;
ALTER SEQUENCE mutual_information_new.running_jobs_running_id_seq RESTART WITH 1;
ALTER SEQUENCE mutual_information_new.avail_jobs_job_id_seq RESTART WITH 10;
DELETE from results.mutual_information_new where True
DELETE FROM classification.avail_jobs a USING classification.avail_jobs b WHERE a.job_id < b.job_id AND a.hash_value = b.hash_value;

DELETE from mutual_information.avail_jobs where job_id>5515;
ALTER sequence mutual_information.avail_jobs_job_id_seq RESTART WITH 5516;

DELETE from automl.avail_jobs where job_id>18 and (dataset='synthetic_imbalanced' or dataset='synthetic_distance_imbalanced');
ALTER sequence automl.avail_jobs_job_id_seq RESTART WITH 16523;
DELETE from mutual_information.running_jobs row WHERE EXISTS(SELECT job_id FROM mutual_information.avail_jobs r WHERE r.job_id = row.job_id and r.learner='mine_mi_estimator_hpo');
SELECT job_id, hash_value, job_allocated_time, job_end_time,evaluation_time FROM automl.avail_jobs row
WHERE EXISTS(SELECT job_id FROM automl.running_jobs r WHERE r.job_id = row.job_id and r.finished=True and learner='auto_gluon' and job_allocated_time > '2023-05-19 13:00:00');


UPDATE automl.avail_jobs
SET evaluation_time =
    CASE
        WHEN job_end_time is null THEN 0
        WHEN EXTRACT(EPOCH FROM (job_end_time - job_allocated_time)) < 0 THEN 0
        WHEN EXTRACT(EPOCH FROM (job_end_time - job_allocated_time)) < 500 THEN EXTRACT(EPOCH FROM (job_end_time - job_allocated_time)) + 3600
        ELSE EXTRACT(EPOCH FROM (job_end_time - job_allocated_time))
    END
WHERE learner = 'auto_gluon';